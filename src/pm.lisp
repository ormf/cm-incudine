;;; **********************************************************************
;;; Copyright (C) 2009 Heinrich Taube, <taube (at) uiuc (dot) edu>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the Lisp Lesser Gnu Public License.
;;; See http://www.cliki.net/LLGPL for the text of this agreement.
;;; **********************************************************************

;;; generated by scheme->cltl from pm.scm on 19-Mar-2009 14:43:23

(in-package :cm)

(in-package :cm)

(defparameter *portmidi-default-input* nil)

(defparameter *portmidi-default-output* nil)

(defparameter *portmidi-default-latency* 5)

(defparameter *portmidi-default-inbuf-size* 512)

(defparameter *portmidi-default-outbuf-size* 2048)

(defparameter *portmidi-default-filter* 0)

(defparameter *portmidi-default-mask* 0)

(progn
 (defclass portmidi-stream (rt-stream midi-stream-mixin)
           ((input :initform *portmidi-default-input* :initarg :input
             :accessor portmidi-input)
            (output :initform *portmidi-default-output* :initarg
             :output :accessor portmidi-output)
            (latency :initform *portmidi-default-latency* :initarg
             :latency :accessor rt-stream-latency)
            (inbufsize :initform *portmidi-default-inbuf-size*
             :initarg :inbuf-size :accessor portmidi-inbuf-size)
            (outbufsize :initform *portmidi-default-outbuf-size*
             :initarg :outbuf-size :accessor portmidi-outbuf-size)
            (receive-data :initform (list nil nil nil nil) :accessor
             rt-stream-receive-data)
            (receive-mode :initform :message :initarg :receive-mode
             :accessor rt-stream-receive-mode)
            (filter :initform *portmidi-default-filter* :initarg
             :filter :accessor portmidi-filter)
            (mask :initform *portmidi-default-mask* :initarg
             :channel-mask :accessor portmidi-channel-mask)
            (offset :initform 0 :initarg :offset :accessor
             portmidi-offset))
           #+metaclasses  (:metaclass io-class))
 (defparameter <portmidi-stream> (find-class 'portmidi-stream))
 (finalize-class <portmidi-stream>)
 (setf (io-class-file-types <portmidi-stream>) '("*.pm"))
 (values))

(defmethod print-object ((obj portmidi-stream) port)
           (let ((name (object-name obj))
                 (pids (event-stream-stream obj))
                 (*print-case* ':downcase))
             (setf name
                     (if name
                         (format nil "~a \"~a\""
                                 (class-name (class-of obj)) name)
                         (format nil "~a"
                                 (class-name (class-of obj)))))
             (if pids
                 (if (car pids)
                     (if (cadr pids)
                         (format port "#<~a (in:~d out:~d)>" name
                                 (car pids) (cadr pids))
                         (format port "#<~a (in:~d)>" name
                                 (car pids)))
                     (if (cadr pids)
                         (format port "#<~a (out:~d)>" name
                                 (cadr pids))
                         (format port "#<~a>" name)))
                 (format port "#<~a>" name))))

(defmethod open-io ((obj portmidi-stream) dir &rest args) dir args
           (when (not (io-open obj))
             (unless (portmidi:portmidi)
               (error
                "Can't open PortMidi connection: PortMidi not loaded."))
             (unless (event-stream-stream obj)
               (flet ((getd (i d l)
                        (cond ((not i) nil)
                              ((eq i t)
                               (portmidi:getdeviceinfo
                                (if (eq d ':input)
                                    (portmidi:getdefaultinputdeviceid)
                                    (portmidi:getdefaultoutputdeviceid))))
                              ((not (eq d (getf l ':type))) nil)
                              ((stringp i)
                               (if (string-equal i (getf l ':name)) l
                                   nil))
                              ((integerp i)
                               (if (eq (getf l ':id) i) l nil))
                              (t nil))))
                 (let ((devs (portmidi:getdeviceinfo))
                       (bsiz (portmidi-outbuf-size obj))
                       (idev nil)
                       (odev nil)
                       (pids (list nil nil))
                       (data (list nil nil)))
                   (do ((tail devs (cdr tail))
                        (i (portmidi-input obj))
                        (o (portmidi-output obj)))
                       ((null tail) nil)
                     (if (and i (not idev))
                         (setf idev (getd i ':input (car tail))))
                     (if (and o (not odev))
                         (setf odev (getd o ':output (car tail)))))
                   (cond
                    ((null devs)
                     (error
                      "open-io: no PortMidi devices available."))
                    ((and idev (getf idev ':open))
                     (error
                      "open-io: PortMidi input device ~D (~S) is already open."
                      (getf idev ':id) (getf idev ':name)))
                    ((and odev (getf odev ':open))
                     (error
                      "open-io: PortMidi output device ~D (~S) is already open."
                      (getf odev ':id) (getf odev ':name)))
                    ((and (not idev) (portmidi-input obj))
                     (error
                      "open-io: '~S' is not a valid :input id. Available devices are: ~S."
                      (portmidi-input obj) devs))
                    ((and (not odev) (portmidi-output obj))
                     (error
                      "open-io: '~S' is not a valid :output id. Available devices are: ~S."
                      (portmidi-output obj) devs))
                    ((and (not idev) (not odev))
                     (error
                      "open-io: Missing :input and/or :output id. Valid devices: ~S."
                      devs)))
                   (portmidi:start)
                   (setf (object-time obj) 0)
                   (when idev
                     (setf idev (getf idev ':id))
                     (rplaca pids idev)
                     (rplaca data
                             (portmidi:openinput idev
                                                 (if (consp bsiz)
                                                     (car bsiz)
                                                     bsiz)))
                     (setf (elt (rt-stream-receive-data obj) 0)
                             (car data))
                     (setf (elt (rt-stream-receive-data obj) 1) idev)
                     (setf (elt (rt-stream-receive-data obj) 2)
                             (if (consp bsiz) (car bsiz) bsiz)))
                   (when odev
                     (setf odev (getf odev ':id))
                     (rplaca (cdr pids) odev)
                     (rplaca (cdr data)
                             (portmidi:openoutput odev
                                                  (if (consp bsiz)
                                                      (cadr bsiz)
                                                      bsiz)
                                                  (rt-stream-latency
                                                   obj))))
                   (setf (event-stream-stream obj) pids)
                   (setf (io-open obj) data)))))
           obj)

(defmethod close-io ((obj portmidi-stream) &rest mode)
           (when (and (eq (car mode) ':force) (io-open obj))
             (let ((data (io-open obj)))
               (if (car data) (portmidi:close (car data)))
               (if (cadr data) (portmidi:close (cadr data)))
               (setf (event-stream-stream obj) nil)
               (setf (elt (rt-stream-receive-data obj) 0) nil)
               (setf (elt (rt-stream-receive-data obj) 1) nil)
               (setf (io-open obj) nil)))
           (values))

(defmethod initialize-io ((obj portmidi-stream))
           (flet ((fn (o s)
                    (let ((f (portmidi-filter o))
                          (m (portmidi-channel-mask o)))
                      (if (consp f) (apply #'portmidi:setfilter s f)
                          (portmidi:setfilter s f))
                      (portmidi:setchannelmask s m))))
             (let ((io (io-open obj)))
               (if (car io) (fn obj (car io)))
               (if (cadr io) (fn obj (cadr io)))
               (setf (portmidi-offset obj) (portmidi:time))
               (setf (object-time obj) 0)
               (channel-tuning-init obj))))

(defun portmidi-open (&rest args)
  (apply #'open-io "midi-port.pm" t args))

(defun portmidi-open? (&optional (port (find-object "midi-port.pm")))
  (if port
      (let ((io (io-open port)))
        (if io
            (if (car io) (if (cadr io) :inout :in)
                (if (cadr io) :out nil))
            nil))
      nil))

(defun portmidi-close (&optional (port (find-object "midi-port.pm")))
  (if (portmidi-open? port)
      (progn
       (if (equal ':running (recv? port)) (recv-stop port))
       (close-io port ':force))
      port)
  port)

(defun pm-message->midi-message (pmm)
  (let ((status (portmidi:message.status pmm)))
    (if (< status 240)
        (if (logtest status 128)
            (let ((stat (ash (logand status 240) -4))
                  (dat2 (portmidi:message.data2 pmm)))
              (when (and (= stat +ml-note-on-opcode+) (= 0 dat2))
                (setf stat +ml-note-off-opcode+)
                (setf dat2 127))
              (make-channel-message stat (logand status 15)
               (portmidi:message.data1 pmm) dat2))
            (error "pm-message->midi-message: running status :("))
        (if (= status 255)
            (error "pm-message->midi-message: meta message??!")
            (let ((type (logand status 15)))
              (if (= type 0)
                  (error "pm-message->midi-message: sysex :(")
                  (make-system-message (logior (ash type 4) 15) 0
                   (portmidi:message.data1 pmm)
                   (portmidi:message.data2 pmm))))))))

(defun midi-message->pm-message (mm)
  (portmidi:message
   (logior (ash (midimsg-upper-status mm) 4)
           (midimsg-lower-status mm))
   (channel-message-data1 mm) (channel-message-data2 mm)))

(defmethod midi-write-message
           ((obj integer) (str portmidi-stream) scoretime data) data
           (cond ((sysex-p obj))
                 ((or (channel-message-p obj) (system-message-p obj))
                  (portmidi:writeshort (second (io-open str))
                                       (if
                                        (scheduling-mode? ':events)
                                        (+ (round (* scoretime 1000))
                                           (portmidi-offset str))
                                        (portmidi:time))
                                       (midi-message->pm-message
                                        obj)))))

(defmethod write-event ((obj midi) (str portmidi-stream) scoretime)
           (let ((keyn (midi-keynum obj))
                 (chan (midi-channel obj))
                 (ampl (midi-amplitude obj))
                 (sched (scheduling-mode)))
             (ensure-velocity ampl keyn)
             (ensure-microtuning keyn chan str)
             (unless (< keyn 0)
               (portmidi:writeshort (second (io-open str))
                                    (if (eq sched ':events)
                                        (+ (round (* scoretime 1000))
                                           (portmidi-offset str))
                                        (portmidi:time))
                                    (portmidi:message
                                     (logior 144 (logand chan 15))
                                     (logand keyn 127)
                                     (logand ampl 127)))
               (enqueue *qentry-message*
                (make-note-off chan keyn 127)
                (+ scoretime (midi-duration obj)) nil sched))
             (values)))

(defmethod write-event
           ((obj midi-event) (str portmidi-stream) scoretime)
           (midi-write-message (midi-event->midi-message obj) str
            scoretime nil))

(defmethod write-event
           ((obj integer) (str portmidi-stream) scoretime)
           (midi-write-message obj str scoretime nil))

(defun portmidi:now () (portmidi:time))

(defun portmidi:output (msg &key at (to *out*) raw)
  (cond
   ((numberp msg)
    (portmidi:writeshort (second (io-open to))
                         (or at (portmidi:time))
                         (if raw msg
                             (midi-message->pm-message msg))))
   ((stringp msg)
    (portmidi:writesysex (second (io-open to))
                         (or at (portmidi:time)) msg))
   (t (portmidi:write (second (io-open to)) msg raw)))
  (values))

(defun parse-pm-output (forms clauses ops)
  clauses
  ops
  (let ((head forms)
        (oper (pop forms))
        (expr nil)
        (args (list))
        (to nil)
        (loop '()))
    (when (null forms)
      (loop-error ops head "Missing '" oper "' expression."))
    (setf expr (pop forms))
    (do ((stop nil))
        ((or stop (null forms)))
      (case (car forms)
        ((to :to)
         (when (null (cdr forms))
           (loop-error ops head "Missing '" oper " to' expression."))
         (setf args (nconc args (list ':to (cadr forms))))
         (setf to t)
         (setf forms (cddr forms)))
        ((at :at)
         (when (null (cdr forms))
           (loop-error ops head "Missing '" oper " at' expression."))
         (setf args (nconc args (list ':at (cadr forms))))
         (setf forms (cddr forms)))
        ((raw :raw)
         (when (null (cdr forms))
           (loop-error ops head "Missing '" oper
            " raw' expression."))
         (setf args (nconc args (list ':raw (cadr forms))))
         (setf forms (cddr forms)))
        (t (setf stop t))))
    (unless to (setf args (nconc args (list ':to '*out*))))
    (setf loop (list `(,oper ,expr ,@args)))
    (values (make-loop-clause 'operator oper 'looping loop) forms)))

(defparameter *process-operators*
  (append *process-operators*
          (list
           (list 'portmidi:output #'parse-pm-output 'task 'to 'at
                 'raw))))

(defun portmidi-record! (seq &rest mp)
       (let* ((str (if (consp mp) (car mp)
                       (find-object "midi-port.pm" )))
              (opn (if (null str) nil
                       (portmidi-open? str))))
         (cond ((not opn)
                (error "portmidi-record!: portmidi stream not open for input."))
               ((eq opn ':out)
                (error "portmidi-record!: ~s only open for output." str))
               (t
                ;; otherwise set true if we also perform midi thru
                (setf opn (if (eq opn :inout) t nil))))
         (if (not seq)
             (remove-receiver! str)
             (let ((ins (if (subobjects seq) t nil)) ; insert into existing seq
                   (off nil)                          ; time offset
                   (map (make-list 16 :initial-element (list)))) ; channel map for on/off pairing
               (if (receiver? str)
                   (error "portmidi-record!: receiver already active."))
               (set-receiver!
                (lambda (mm ms)
                  (if opn (write-event mm str ms)) ; midi thru 
                  (if (not off) (set! off ms)) ; cache time of first message
                  (cond ((or (note-off-p mm)
                             (and (note-on-p mm) (= 0 (note-on-velocity mm))))
                         (let* ((chn (note-off-channel mm))
                                (key (note-off-key mm))
                                (ons (list-ref map chn)))
                           ;; ons is time ordered list ((<on> . <ms>) ...)
                           (when (consp ons) ; have on to pair with
                             (let ((aon nil)  ; pair with earliest on
                                   (obj nil))
                               (cond ((= (note-on-key (car (car ons))) key)
                                      (set! aon (car ons))
                                      (list-set! map chn (cdr ons)))
                                     (t
                                      ;; search for corresponding on, splice out
                                      (do ()
                                          ((or (null (cdr ons)) aon)
                                           nil)
                                        (if (= key (note-on-key
                                                    (car (car (cdr ons)))))
                                            (begin (set! aon (car (cdr ons)))
                                                   (set-cdr! ons (cddr ons)))
                                            (set! ons (cdr ons))))))
                               ;; aon is (<msg> . <ms>)
                               (when aon
                                 (set! obj (make <midi> 
                                                 :time (/ (- (cdr aon) off)
                                                          1000.0)
                                                 :duration (/ (- ms (cdr aon))
                                                              1000.0)
                                                 :keynum (note-on-key (car aon))
                                                 :amplitude (/ (note-on-velocity
                                                                (car aon))
                                                               127.0)
                                                 :channel (note-on-channel
                                                           (car aon))))
                                 ;; insert if seq contained objects else append
                                 (if ins (insert-object seq obj)
                                     (append-object obj seq)))))))
                        ((note-on-p mm)
                         (let* ((chn (note-on-channel mm))
                                (ons (list-ref map chn)))
                           ;; append mm to time ordered ons ((<on> . <ms>) ...)
                           (if (null ons)
                               (list-set! map chn (list (cons mm ms)))
                               (append! ons (list (cons mm ms))))))
                        ((channel-message-p mm)
                         (midi-message->midi-event mm :time (/ (- ms off)
                                                               1000.0)))))
                str)))))
